# 7.1 User and Group Management

"Who has access to what?" That question kept me awake during my first security audit as a junior admin. I'd inherited a system where everyone seemed to have sudo access, service accounts had expired passwords, and nobody could explain why user 'temp2019' still existed in 2023. Let me share what I've learned about managing users and groups in a way that scales, stays secure, and won't haunt your successors.

## Understanding the Linux Identity Model

Before diving into commands, let's understand how Linux thinks about identity. Every process, file, and resource in Linux is owned by someone and accessible to specific groups. This isn't just about security; it's about organizing work and automating permissions at scale.

### The Trinity of Identity

Linux identifies users through three key pieces:
1. **Username**: Human readable identifier
2. **UID (User ID)**: The actual number Linux uses internally
3. **GID (Group ID)**: Primary group membership

Here's the critical insight: Linux doesn't care about usernames. It only sees numbers. This distinction has saved me countless hours debugging permission issues.

```bash
# See the truth about identity
id
# uid=1000(alice) gid=1000(alice) groups=1000(alice),4(adm),27(sudo),108(lxd)

# What Linux actually sees
stat n %u:%g /home/alice
# 1000:1000
```

### The User Database

Users aren't stored in some complex database; they live in plain text files. Understanding these files is crucial:

```bash
# The main cast of characters
/etc/passwd   # User account information
/etc/shadow   # Encrypted passwords and aging info
/etc/group    # Group definitions
/etc/gshadow  # Group passwords (rarely used)
```

Let's decode a passwd entry:
```
alice:x:1000:1000:Alice Smith,,,:/home/alice:/bin/bash
```

Breaking this down:
* `alice`: Username
* `x`: Password placeholder (actual password in /etc/shadow)
* `1000`: UID
* `1000`: Primary GID
* `Alice Smith,,,`: GECOS field (full name and other info)
* `/home/alice`: Home directory
* `/bin/bash`: Login shell

I learned to read these files fluently after a database driven user system failed and we had to reconstruct user accounts from backups.

## User Management: Beyond useradd

### Creating Users the Right Way

Most tutorials show you `useradd` and stop there. Real world user creation requires more thought:

```bash
# Basic user creation
useradd m s /bin/bash c "Alice Smith" alice

# But here's what I actually use in production
useradd \
  m \                      # Create home directory
  s /bin/bash \            # Set shell
  c "Alice Smith" \        # Comment/full name
  g developers \           # Primary group
  G sudo,docker,www data \ # Additional groups
  e 2024 12 31 \          # Account expiry
  k /etc/skel.dev \        # Custom skeleton directory
  alice

# Set initial password
passwd alice
```

The skeleton directory trick (`/etc/skel.dev`) lets me provision different default configurations for different user types. Developers get git configs, operators get monitoring shortcuts.

### User Templates and Automation

Manual user creation doesn't scale. Here's a pattern I use for bulk operations:

```bash
#!/bin/bash
# User provisioning script

USER_TYPE=$1
USERNAME=$2
FULL_NAME=$3

case $USER_TYPE in
  developer)
    GROUPS="developers,docker,vcs"
    SHELL="/bin/bash"
    SKEL="/etc/skel.dev"
    ;;
  operator)
    GROUPS="operators,monitoring,logs"
    SHELL="/bin/bash"
    SKEL="/etc/skel.ops"
    ;;
  service)
    GROUPS="services"
    SHELL="/bin/false"
    SKEL="/etc/skel.service"
    ;;
esac

# Create user with appropriate settings
useradd \
  m \
  s "$SHELL" \
  c "$FULL_NAME" \
  G "$GROUPS" \
  k "$SKEL" \
  "$USERNAME"

# Generate secure random password
PASSWORD=$(openssl rand base64 32)
echo "$USERNAME:$PASSWORD" | chpasswd

# Force password change on first login (except service accounts)
if [ "$USER_TYPE" != "service" ]; then
  passwd e 0 "$USERNAME"
fi

# Log the creation
logger "User $USERNAME ($USER_TYPE) created by $USER"
```

### Service Accounts: Special Considerations

Service accounts need different treatment than human users:

```bash
# Create a service account properly
useradd \
  r \                    # System account (UID < 1000)
  s /bin/false \         # No login shell
  d /var/lib/myservice \ # Service specific home
  c "MyService Account" \
  myservice

# Lock the account (no password login possible)
passwd l myservice

# But still allow key based operations if needed
mkdir p /var/lib/myservice/.ssh
# ... configure keys ...
```

The number of times I've seen service accounts with `/bin/bash` and weak passwords would shock you. These accounts are often the easiest attack vector.

## Group Management: Organizing Access

Groups are how Linux implements role based access control. Understanding group dynamics is crucial for security and efficiency.

### Primary vs Supplementary Groups

Every user has exactly one primary group and can have multiple supplementary groups:

```bash
# Check current groups
groups alice
# alice : alice developers docker www data

# The primary group matters for file creation
su alice c "touch /tmp/test && ls l /tmp/test"
# rw rw r   1 alice alice 0 Jan 20 10:00 /tmp/test

# Change primary group temporarily
newgrp developers
```

### Dynamic Group Management

Adding and removing users from groups without disrupting their work:

```bash
# Add user to group (requires re login to take effect)
usermod aG docker alice

# Remove from group (trickier)
# Must specify all groups they should remain in
usermod G developers,sudo alice

# Better approach: use gpasswd
gpasswd a alice docker  # Add
gpasswd d alice docker  # Delete

# Apply group changes without logout
# User must run: newgrp docker
# Or: su $USER
```

I've learned to notify users after group changes. Nothing frustrates people more than permissions that "should work" but don't because they haven't relogged.

### Creating Purpose Built Groups

Groups should represent roles or access needs, not departments:

```bash
# Good group design
groupadd g 2000 app readers
groupadd g 2001 app writers  
groupadd g 2002 log viewers
groupadd g 2003 deployers

# Bad group design (too broad)
groupadd engineering  # What access does this grant?
groupadd management   # Organizational, not functional
```

## Advanced User Attributes

### Password Policies and Aging

Password management goes beyond just setting them:

```bash
# View password aging information
chage l alice

# Set password policies
chage \
  m 7 \      # Minimum days between changes
  M 90 \     # Maximum days before expiry
  W 14 \     # Warning days before expiry
  I 7 \      # Inactive days before lock
  alice

# Force immediate password change
chage d 0 alice

# Set account expiration
chage E 2024 12 31 alice
```

But here's the reality: password policies often reduce security by encouraging predictable patterns. I prefer strong initial passwords with MFA over frequent rotation.

### User Limits and Quotas

Preventing resource exhaustion by users:

```bash
# Set limits in /etc/security/limits.conf
alice    soft    nproc     1000   # Process limit
alice    hard    nproc     2000
alice    soft    nofile    4096   # Open files
alice    hard    nofile    8192
@developers soft core      0      # No core dumps
@developers hard cpu       60     # CPU time (minutes)

# Disk quotas (requires quota package)
setquota u alice 1G 1.2G 100K 120K /home

# Check quota usage
quota u alice
```

I learned about limits the hard way when a developer's runaway script spawned 30,000 processes and brought down a production server.

### Sudo Configuration: Fine Grained Access

Sudo isn't just about all or nothing access:

```bash
# Edit sudoers safely
visudo

# Basic patterns
alice ALL=(ALL:ALL) ALL                    # Full access
bob   ALL=(root) NOPASSWD: /bin/systemctl  # Specific command

# Advanced patterns
# User alias
User_Alias ADMINS = alice, bob, charlie
User_Alias DEVELOPERS = @developers, !intern

# Command alias  
Cmnd_Alias SERVICES = /bin/systemctl restart nginx, \
                      /bin/systemctl reload nginx
Cmnd_Alias DEBUGGING = /usr/bin/strace, /usr/bin/tcpdump

# Apply policies
ADMINS     ALL = ALL
DEVELOPERS ALL = SERVICES, DEBUGGING
```

### PAM: The Authentication Framework

PAM (Pluggable Authentication Modules) controls how users authenticate:

```bash
# Common PAM configurations
/etc/pam.d/common auth     # Authentication rules
/etc/pam.d/common account  # Account validation
/etc/pam.d/common session  # Session setup
/etc/pam.d/common password # Password policies

# Example: Require strong passwords
# In /etc/pam.d/common password
password requisite pam_pwquality.so \
  minlen=12 ucredit= 1 lcredit= 1 \
  dcredit= 1 ocredit= 1
```

## User Environment Management

### Shell Initialization

Understanding the login process helps manage user environments:

```bash
# Login shell sequence
/etc/profile          # System wide
~/.bash_profile       # User specific (login shells)
~/.bashrc            # User specific (all shells)
/etc/bash.bashrc     # System wide bashrc

# For non bash shells
~/.profile           # Shell agnostic profile
```

I maintain different `/etc/profile.d/` scripts for different environments:

```bash
# /etc/profile.d/dev environment.sh
if groups | grep q developers; then
  export EDITOR=vim
  export GIT_PS1_SHOWDIRTYSTATE=1
  alias ll='ls la'
fi

# /etc/profile.d/prod warning.sh
if [ "$HOSTNAME" =~ prod ]; then
  echo "WARNING: Production System"
  export PS1="\[\e[31m\][PROD]\[\e[0m\] $PS1"
fi
```

### Home Directory Management

Home directories need regular maintenance:

```bash
# Find orphaned home directories
comm 23 \
  <(ls /home | sort) \
  <(getent passwd | cut d: f6 | grep ^/home | cut d/ f3 | sort)

# Archive inactive user homes
INACTIVE_DAYS=180
find /home mindepth 1 maxdepth 1 type d | while read dir; do
  user=$(basename "$dir")
  if ! id "$user" &>/dev/null; then
    tar czf "/archive/homes/$user $(date +%Y%m%d).tar.gz" "$dir"
    rm rf "$dir"
  fi
done

# Monitor home directory sizes
du sh /home/* | sort hr | head 20
```

## Security Best Practices

### Account Auditing

Regular audits prevent security drift:

```bash
#!/bin/bash
# User audit script

echo "=== Users with UID 0 ==="
awk F: '$3 == 0 {print $1}' /etc/passwd

echo "=== Users with empty passwords ==="
awk F: '$2 == "" {print $1}' /etc/shadow

echo "=== Users with no password aging ==="
while IFS=: read user pass rest; do
  if [ "$pass" != "*" ] && [ "$pass" != "!" ]; then
    if ! chage l "$user" | grep q "Password expires"; then
      echo "$user"
    fi
  fi
done < /etc/shadow

echo "=== Service accounts with shells ==="
awk F: '$3 < 1000 && $7 !~ /false|nologin/ {print $1,$7}' /etc/passwd

echo "=== Sudo users ==="
grep '^[^#].*ALL.*ALL' /etc/sudoers /etc/sudoers.d/* 2>/dev/null
```

### Centralized Authentication

For larger environments, consider centralized authentication:

* **LDAP/Active Directory**: Central user database
* **SSSD**: System Security Services Daemon for caching
* **Kerberos**: Ticket based authentication
* **OAuth/SAML**: Modern web based authentication

But remember: centralized authentication is a single point of failure. Always maintain local emergency accounts.

### Monitoring User Activity

Track what users are doing without being invasive:

```bash
# Last login information
lastlog

# Current sessions
w
who

# Command history (if not disabled)
# User histories in ~/.bash_history

# Authentication logs
journalctl u sshd
grep "session opened" /var/log/auth.log

# Failed login attempts
faillog
journalctl p warning g "authentication failure"
```

## Common Pitfalls and Solutions

### The UID Mismatch Problem

When UIDs don't match across systems:

```bash
# Fix ownership after UID change
find / uid 1001 exec chown alice {} \;

# Better: maintain consistent UIDs
# In /etc/adduser.conf or automation
FIRST_UID=10000
LAST_UID=19999
```

### The Deleted User Cleanup

When users leave, cleaning up properly:

```bash
# Full user removal checklist
USERNAME="departed_user"

# 1. Kill all processes
pkill u "$USERNAME"

# 2. Remove from all groups
groups "$USERNAME" | tr ' ' '\n' | tail n +2 | \
  xargs I{} gpasswd d "$USERNAME" {}

# 3. Remove cron jobs
crontab u "$USERNAME" r

# 4. Remove at jobs
atq | grep "$USERNAME" | cut f1 | xargs atrm

# 5. Archive home directory
tar czf "/archive/$USERNAME $(date +%Y%m%d).tar.gz" "/home/$USERNAME"

# 6. Finally delete user
userdel r "$USERNAME"
```

### Integration with Configuration Management

Modern environments need user management as code:

```yaml
# Ansible example
users:
   name: alice
   groups: [developers, docker]
   shell: /bin/bash
   generate_ssh_key: yes
   ssh_key_bits: 4096
   password_lock: no

# Puppet example
user { 'alice':
  ensure     => present,
  groups     => ['developers', 'docker'],
  shell      => '/bin/bash',
  managehome => true,
}
```

## Looking Forward

User management is evolving. Containerization challenges traditional user models. Cloud native applications use service accounts and IAM roles. But the fundamentals remain: understanding identity, managing access, and maintaining security.

The most important lesson? User management is about people, not just technical controls. Good user management makes people productive while keeping systems secure. It's about finding that balance between convenience and control, between automation and audit ability.

Remember: every user account is a potential security boundary. Manage them with the respect they deserve, automate what you can, and always know who has access to what. Your future self will thank you during the next security audit.