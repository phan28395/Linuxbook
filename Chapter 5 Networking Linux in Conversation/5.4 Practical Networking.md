# 5.4 Practical Networking

You know that moment when your application suddenly can't reach the database? Or when SSH takes forever to connect? Or when that container can't talk to another container that's supposedly on the same network? After two decades of Linux administration, I've learned that networking issues follow patterns. Understanding these patterns transforms you from someone who randomly tries things to someone who systematically solves problems.

## Real World Networking Scenarios

Let me share how networking actually works in production environments. It's not about memorizing every flag for `tcpdump` or knowing arcane `iptables` syntax. It's about understanding what questions to ask and which tools reveal the answers.

### The Connection Refused Mystery

Here's a scenario I've encountered countless times: A developer messages you saying their application can't connect to the database. "Connection refused" they say. Your systematic approach begins:

First, verify basic connectivity. Can you ping the database server? This tells you if the network path exists:

```bash
ping database.internal.company.com
```

If ping works, the network layer is fine. Now check if the service is actually listening:

```bash
# On the database server
ss l n | grep 3306  # For MySQL
# or
netstat ltnp | grep 5432  # For PostgreSQL
```

No output? The service isn't listening. But wait, there's more to check. Is the service bound only to localhost?

```bash
# Check the actual bind address
ss ltn | grep :3306
# You might see:
# LISTEN 0 128 127.0.0.1:3306
```

There's your problem. The database is only listening on localhost, not on the network interface. This is a security default that trips up many installations.

### The Intermittent Timeout Pattern

More challenging are intermittent issues. Your monitoring shows occasional timeouts to a service. Users complain sporadically. These require different tools.

Start with `mtr` (My TraceRoute), which combines ping and traceroute to show packet loss patterns:

```bash
mtr database.internal.company.com
```

Watch for a few minutes. Are you seeing packet loss at a specific hop? That's your network team's problem. Packet loss only at the final destination? Time to investigate the server.

For deeper analysis, `tcpdump` becomes your microscope:

```bash
# Capture traffic to the problematic service
tcpdump i eth0 host database.internal.company.com and port 3306 w capture.pcap

# In another terminal, reproduce the issue
# Then analyze with Wireshark or tcpdump itself
```

Look for TCP retransmissions, RST packets, or unusual delays between SYN and SYN/ACK. These reveal network quality issues that simple connectivity tests miss.

### Container Networking Puzzles

Container networking adds layers of abstraction that can confuse even experienced admins. I learned this migrating a microservices architecture to Kubernetes.

When containers can't communicate, start by understanding the network namespace:

```bash
# List network namespaces
ip netns list

# Execute commands in a container's namespace
docker exec container_name ip addr show
docker exec container_name ip route show
```

Bridge networks, overlay networks, host networking, each has its place and its peculiarities. The key insight: containers use Linux network namespaces, just with orchestration on top.

For Docker networks:

```bash
# Inspect the network configuration
docker network inspect bridge

# See which containers are on which networks
docker network ls
docker ps format "table {{.Names}}\t{{.Networks}}"
```

In Kubernetes, the complexity increases:

```bash
# Check service endpoints
kubectl get endpoints

# Verify network policies
kubectl get networkpolicies

# Debug from inside a pod
kubectl exec it podname  /bin/sh
# Then use standard Linux networking tools
```

### The DNS Dilemma

DNS issues masquerade as network problems. That "can't connect" error might actually be "can't resolve." Always verify:

```bash
# Test DNS resolution
nslookup service.internal.company.com
dig service.internal.company.com
host service.internal.company.com

# Check which DNS servers are being used
cat /etc/resolv.conf

# For systemd resolved systems
systemd resolve status
```

In containerized environments, DNS gets even more interesting:

```bash
# Docker uses embedded DNS
docker exec container_name cat /etc/resolv.conf
# Usually points to 127.0.0.11

# Kubernetes has its own DNS
kubectl exec pod_name  cat /etc/resolv.conf
# Points to the cluster DNS service
```

## Performance Optimization Patterns

Once things work, making them work well becomes the challenge. Network performance optimization follows patterns too.

### Identifying Bottlenecks

Start with `iftop` for real time bandwidth usage:

```bash
iftop i eth0
```

This shows you which connections consume bandwidth. Surprised by the results? You might discover forgotten backup jobs, chatty monitoring, or that someone's streaming video.

For historical analysis, `vnstat` provides long term statistics:

```bash
vnstat i eth0 d  # Daily statistics
vnstat i eth0 m  # Monthly statistics
```

### TCP Tuning Wisdom

Linux's TCP stack is remarkably well tuned out of the box, but specific workloads benefit from adjustments:

```bash
# Check current TCP settings
sysctl net.ipv4.tcp_congestion_control
sysctl net.core.rmem_max
sysctl net.core.wmem_max

# For high throughput environments
echo 'net.core.rmem_max = 134217728' >> /etc/sysctl.conf
echo 'net.core.wmem_max = 134217728' >> /etc/sysctl.conf
echo 'net.ipv4.tcp_rmem = 4096 87380 134217728' >> /etc/sysctl.conf
echo 'net.ipv4.tcp_wmem = 4096 65536 134217728' >> /etc/sysctl.conf
```

But beware: blindly copying TCP tuning parameters from blog posts often makes things worse. Measure, adjust, measure again.

### Connection Tracking Limits

High traffic servers hit connection tracking limits, manifesting as random connection failures:

```bash
# Check current connection tracking
conntrack L
conntrack C  # Just the count

# See the limits
sysctl net.netfilter.nf_conntrack_max
sysctl net.netfilter.nf_conntrack_count
```

When count approaches max, new connections fail. The fix:

```bash
echo 'net.netfilter.nf_conntrack_max = 1048576' >> /etc/sysctl.conf
sysctl p
```

## Security in Practice

Network security isn't just about firewalls. It's about defense in depth.

### Practical Firewall Management

Instead of learning iptables syntax, understand firewall concepts. Modern systems use `firewalld` or `ufw` for good reason:

```bash
# FirewallD approach
firewall cmd permanent add service=https
firewall cmd permanent add rich rule='rule family="ipv4" source address="10.0.0.0/8" port port="3306" protocol="tcp" accept'
firewall cmd reload

# UFW approach
ufw allow from 10.0.0.0/8 to any port 3306
ufw status verbose
```

These tools generate iptables rules but provide better abstractions for common scenarios.

### Monitoring for Anomalies

Real security comes from knowing what's normal:

```bash
# Establish baseline connections
ss ant | awk '{print $5}' | cut d: f1 | sort | uniq c | sort nr | head 20

# Run periodically and compare
# Sudden new IPs? Investigate
```

For automated monitoring:

```bash
# Log all new connections
iptables I INPUT m state state NEW j LOG log prefix "NEW CONNECTION: "

# Watch for port scans
iptables A INPUT p tcp tcp flags ALL NONE j LOG log prefix "NULL SCAN: "
iptables A INPUT p tcp tcp flags ALL ALL j LOG log prefix "XMAS SCAN: "
```

### Securing Services

Each service has its own security considerations. SSH, being the gateway to your systems, deserves special attention:

```bash
# Modern SSH configuration
cat >> /etc/ssh/sshd_config << EOF
# Disable root login
PermitRootLogin no

# Key only authentication
PasswordAuthentication no
PubkeyAuthentication yes

# Limit users
AllowUsers alice bob charlie

# Rate limiting
MaxStartups 10:30:60
MaxAuthTries 3
EOF

systemctl restart sshd
```

## Advanced Patterns

Some scenarios require deeper Linux networking knowledge.

### Network Namespaces for Testing

Create isolated network environments for testing:

```bash
# Create a namespace
ip netns add testnet

# Create virtual ethernet pair
ip link add veth0 type veth peer name veth1

# Move one end to the namespace
ip link set veth1 netns testnet

# Configure addresses
ip addr add 10.0.0.1/24 dev veth0
ip link set veth0 up

ip netns exec testnet ip addr add 10.0.0.2/24 dev veth1
ip netns exec testnet ip link set veth1 up
ip netns exec testnet ip link set lo up

# Now you have an isolated network for testing
ip netns exec testnet ping 10.0.0.1
```

This technique helps reproduce network issues safely.

### Traffic Shaping for Testing

Simulate poor network conditions to test application resilience:

```bash
# Add latency
tc qdisc add dev eth0 root netem delay 100ms

# Add packet loss
tc qdisc change dev eth0 root netem loss 1%

# Simulate bandwidth limits
tc qdisc add dev eth0 root handle 1: htb default 30
tc class add dev eth0 parent 1: classid 1:1 htb rate 1mbit

# Remove all traffic shaping
tc qdisc del dev eth0 root
```

These tools reveal how applications behave under stress.

### eBPF Network Programs

The cutting edge of Linux networking involves eBPF:

```bash
# Example: Count packets by protocol
bpftrace e 'kprobe:ip_rcv { @proto[((struct iphdr *)arg1) >protocol] = count(); }'

# Monitor TCP retransmits
bpftrace e 'tracepoint:tcp:tcp_retransmit_skb { printf("Retransmit to %s\n", ntop(args >daddr)); }'
```

eBPF provides unprecedented visibility into kernel networking behavior without performance impact.

## The Production Mindset

Real world networking differs from textbook examples. In production:

Always have a rollback plan. Before changing network configuration, know how to revert:

```bash
# Save current iptables rules
iptables save > /tmp/iptables.backup

# Test your changes
# If something breaks:
iptables restore < /tmp/iptables.backup
```

Document what's normal. When crisis hits, you need baselines:

```bash
# Create a network baseline
date >> /var/log/network_baseline.log
ip addr show >> /var/log/network_baseline.log
ip route show >> /var/log/network_baseline.log
ss ant >> /var/log/network_baseline.log
iptables L n v >> /var/log/network_baseline.log
```

Think in layers. Network problems can be:
* Physical (cable, switch port)
* Data link (VLAN configuration)
* Network (routing, IP configuration)
* Transport (TCP tuning, port availability)
* Application (service configuration)

Check each layer systematically.

## Learning from Failure

Every network outage teaches lessons. A few from my experience:

MTU mismatches cause mysterious failures. Large packets work fine until they don't:

```bash
# Test with different packet sizes
ping M do s 1500 c 4 database.server
ping M do s 1400 c 4 database.server
# If 1400 works but 1500 doesn't, you have an MTU issue
```

Asymmetric routing breaks stateful firewalls. Traffic goes out one path, returns another:

```bash
# Trace both directions
traceroute database.server
# Then from database server:
traceroute back to source
# Different paths? There's your problem
```

DNS cache poisoning manifests as random failures. One user works, another doesn't:

```bash
# Compare DNS results from different servers
dig @8.8.8.8 service.company.com
dig @1.1.1.1 service.company.com
dig @your.internal.dns service.company.com
# Different results indicate cache issues
```

## The Path Forward

Practical networking mastery comes from:

Building mental models. Understand packet flow through your infrastructure. Visualize the path from user to service and back.

Developing systematic approaches. Random troubleshooting wastes time. Follow consistent patterns.

Learning from production. Every issue teaches something. Document problems and solutions.

Staying curious. Networking evolves constantly. New protocols, new tools, new patterns emerge.

Most importantly, remember that networking serves applications. The goal isn't perfect network configuration, it's reliable service delivery. Sometimes the simple solution beats the technically elegant one.

As you work with networks, you'll develop intuition. That "connection refused" error will immediately suggest three likely causes. Intermittent timeouts will point you to specific diagnostics. This intuition, built on understanding and experience, makes you invaluable in our increasingly connected world.

The network is the computer, as Sun Microsystems said decades ago. Today, that's more true than ever. Master practical networking, and you master a fundamental aspect of modern computing.