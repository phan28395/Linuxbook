# 5.2 Network Configuration and Tools

After years of helping teams debug network issues at 3 AM, I've learned that network configuration is where theory meets reality in often surprising ways. Understanding how Linux manages network interfaces, addresses, and connections transforms you from someone who copies configurations to someone who designs network solutions.

## The Modern Network Interface Model

Linux has evolved its network management significantly over the decades. When I started, we edited configuration files directly and hoped for the best. Today's landscape offers multiple approaches, each with its strengths.

### Understanding Network Interfaces

Every network conversation starts with an interface. Think of these as the doors through which your Linux system communicates with the world. The naming alone tells a story of Linux evolution.

Traditional interfaces followed simple patterns: eth0 for the first Ethernet interface, wlan0 for wireless. But modern systems use predictable network interface names based on hardware properties. An interface named enp3s0 tells you it's an Ethernet device on PCI bus 3, slot 0. This predictability prevents the musical chairs that used to happen when hardware changed.

```bash
# View all network interfaces
ip link show

# The old way still works
ifconfig -a

# But ip provides richer information
ip addr show
```

What you see reveals the system's network personality. Each interface has states (UP/DOWN), capabilities (BROADCAST, MULTICAST), and addresses. The flags tell stories: PROMISC means the interface is listening to all traffic, useful for monitoring but also a security consideration.

### IP Address Management

Addresses are more than numbers; they're your system's identity on the network. Linux supports multiple addresses per interface, a feature I've used countless times for migration projects and service isolation.

```bash
# Add an IP address
sudo ip addr add 192.168.1.100/24 dev eth0

# Remove an IP address
sudo ip addr del 192.168.1.100/24 dev eth0

# The persistent way varies by distribution
# NetworkManager (modern approach)
nmcli con mod "Wired connection 1" ipv4.addresses 192.168.1.100/24
nmcli con mod "Wired connection 1" ipv4.method manual
nmcli con up "Wired connection 1"
```

IPv6 adds another dimension. Linux handles it elegantly, often autoconfiguring addresses through router advertisements. But understanding when you have fe80:: link local addresses versus globally routable ones matters for troubleshooting.

## Network Configuration Approaches

Modern Linux offers three main paths for network configuration, each suited to different scenarios. Understanding when to use each separates competent administrators from those who truly orchestrate systems.

### NetworkManager: The Desktop Champion

NetworkManager excels at dynamic environments. It handles WiFi, VPNs, and mobile broadband with grace. The nmcli tool provides powerful command line control:

```bash
# List connections
nmcli connection show

# Create a new connection
nmcli con add con-name "Office Network" \
  type ethernet \
  ifname eth0 \
  ipv4.method manual \
  ipv4.addresses 10.0.1.50/24 \
  ipv4.gateway 10.0.1.1 \
  ipv4.dns "8.8.8.8 8.8.4.4"

# WiFi connection
nmcli device wifi connect "NetworkName" password "SecretPassword"

# Check device status
nmcli device status
```

NetworkManager's strength lies in handling complexity transparently. It manages DNS resolution, default routes, and metric priorities automatically. For laptops and workstations, it's usually the right choice.

### Systemd networkd: The Server Stalwart

For servers, systemd networkd offers predictable, static configuration. It starts earlier in the boot process and has minimal dependencies:

```bash
# Basic configuration in /etc/systemd/network/10-eth0.network
[Match]
Name=eth0

[Network]
Address=10.0.1.50/24
Gateway=10.0.1.1
DNS=8.8.8.8
DNS=8.8.4.4

# Enable and start
sudo systemctl enable systemd-networkd
sudo systemctl start systemd-networkd
```

The beauty of systemd networkd lies in its declarative approach. You describe the desired state; it handles the implementation. For servers that need consistent, reliable networking, this predictability is invaluable.

### Traditional Configuration Files

Some distributions maintain compatibility with traditional /etc/network/interfaces (Debian/Ubuntu) or /etc/sysconfig/network scripts (Red Hat/CentOS). While considered legacy, understanding them helps when maintaining older systems:

```bash
# Debian/Ubuntu: /etc/network/interfaces
auto eth0
iface eth0 inet static
    address 192.168.1.100
    netmask 255.255.255.0
    gateway 192.168.1.1
    dns-nameservers 8.8.8.8 8.8.4.4

# Bring up interface
sudo ifup eth0
```

## Essential Networking Tools

The right tool can turn hours of frustration into minutes of clarity. Here are the ones I reach for daily.

### The IP Command Suite

The ip command is your Swiss Army knife for networking. It replaces numerous older tools with a consistent interface:

```bash
# Show routing table
ip route show

# Add a route
sudo ip route add 10.10.0.0/16 via 192.168.1.254

# Monitor network changes in real time
ip monitor

# Show network statistics
ip -s link show eth0

# Neighbor (ARP) table
ip neigh show
```

Each subcommand reveals different aspects of network state. The color output (ip -c) helps critical information stand out during troubleshooting sessions.

### DNS Troubleshooting

DNS issues cause more outages than I care to remember. Linux provides excellent tools for DNS debugging:

```bash
# Quick lookup
host google.com
nslookup google.com

# Detailed DNS queries
dig google.com
dig +trace google.com  # Follow delegation path
dig @8.8.8.8 google.com  # Query specific server

# Check system resolution
getent hosts google.com

# View resolver configuration
cat /etc/resolv.conf
resolvectl status  # SystemD systems
```

Understanding the resolution chain matters. Does /etc/hosts override? Is nsswitch.conf routing queries correctly? SystemD resolved adds another layer with its caching and DNSSEC validation.

### Connection Analysis

When applications report network issues, these tools reveal the truth:

```bash
# Active connections
ss -tunap  # Replaces netstat
netstat -tunap  # Still widely used

# Test connectivity
ping -c 4 google.com
ping6 -c 4 google.com  # IPv6

# Trace route path
traceroute google.com
mtr google.com  # Combines ping and traceroute

# Port scanning
nc -zv localhost 22  # Test specific port
nmap -p 80,443 scanme.nmap.org  # More comprehensive
```

The ss command deserves special attention. It's faster than netstat and provides powerful filtering:

```bash
# Show all TCP connections
ss -t

# Show listening ports with process info
sudo ss -tlnp

# Filter by state
ss state established

# Show socket memory usage
ss -m
```

### Traffic Analysis

Sometimes you need to see the actual packets. Linux provides powerful tools for this:

```bash
# Capture packets
sudo tcpdump -i eth0 -n port 80
sudo tcpdump -i any -w capture.pcap  # Save for analysis

# More user friendly capture
sudo tshark -i eth0 -f "tcp port 443"

# Monitor bandwidth usage
iftop -i eth0
nethogs  # Shows per process bandwidth
iptraf-ng  # Comprehensive traffic monitor
```

Understanding when to use each tool matters. Quick bandwidth check? iftop. Debugging protocol issues? tcpdump with Wireshark analysis. Per application usage? nethogs.

## Advanced Configuration Patterns

Real world networking often requires sophisticated setups. Here are patterns I've implemented countless times.

### Network Bonding and Teaming

For reliability and performance, combining multiple interfaces makes sense:

```bash
# Using NetworkManager for bonding
nmcli con add type bond con-name bond0 ifname bond0 \
  bond.options "mode=active-backup,miimon=100"

nmcli con add type ethernet con-name bond0-port1 \
  ifname eth0 master bond0

nmcli con add type ethernet con-name bond0-port2 \
  ifname eth1 master bond0

# Verify bonding status
cat /proc/net/bonding/bond0
```

Different modes serve different purposes. Active backup for redundancy, 802.3ad for switch supported aggregation, balance rr for simple load distribution. The choice depends on your infrastructure and requirements.

### VLAN Configuration

VLANs let you segment networks logically. Linux handles them elegantly:

```bash
# Load 8021q module
sudo modprobe 8021q

# Create VLAN interface
sudo ip link add link eth0 name eth0.100 type vlan id 100
sudo ip addr add 192.168.100.1/24 dev eth0.100
sudo ip link set eth0.100 up

# NetworkManager approach
nmcli con add type vlan con-name vlan100 \
  dev eth0 id 100 \
  ipv4.method manual \
  ipv4.addresses 192.168.100.1/24
```

VLANs become powerful when combined with network namespaces or container networking, enabling sophisticated multi tenant architectures.

### Network Namespaces

Namespaces provide network isolation, fundamental to container technologies:

```bash
# Create namespace
sudo ip netns add isolated

# Run command in namespace
sudo ip netns exec isolated ip addr show

# Create veth pair for namespace connectivity
sudo ip link add veth0 type veth peer name veth1
sudo ip link set veth1 netns isolated

# Configure addresses
sudo ip addr add 10.1.1.1/24 dev veth0
sudo ip netns exec isolated ip addr add 10.1.1.2/24 dev veth1
```

Understanding namespaces unlocks advanced networking scenarios: isolated test environments, container networking, and complex routing setups.

## Troubleshooting Network Issues

Network problems follow patterns. After decades of debugging, I've developed a systematic approach that rarely fails.

### The Layered Approach

Start physical, work up the stack:

1. **Physical/Link Layer**: Is the cable connected? Link lights active?
   ```bash
   ip link show eth0
   ethtool eth0  # Check physical properties
   dmesg | grep eth0  # Hardware messages
   ```

2. **IP Layer**: Do we have addresses? Can we reach the gateway?
   ```bash
   ip addr show
   ip route get 8.8.8.8
   ping -c 4 _gateway  # SystemD resolved syntax
   ```

3. **DNS Resolution**: Can we resolve names?
   ```bash
   systemd-resolve --status
   dig @127.0.0.53 google.com
   dig @8.8.8.8 google.com
   ```

4. **Application Layer**: Can applications connect?
   ```bash
   curl -v http://example.com
   telnet example.com 80
   openssl s_client -connect example.com:443
   ```

### Common Patterns and Solutions

**Intermittent Connectivity**: Often indicates duplex mismatches or cable issues. Check ethtool for errors and speed/duplex settings.

**DNS Timeouts**: Multiple DNS servers with one unreachable causes delays. Test each server individually.

**Asymmetric Routing**: Packets taking different paths in and out. Use tcpdump on both ends to verify.

**MTU Issues**: Manifests as hanging connections. Test with ping using different packet sizes:
```bash
ping -M do -s 1472 google.com  # Test 1500 byte MTU
```

### Performance Optimization

Network performance tuning requires understanding both your workload and the kernel's behavior:

```bash
# View current TCP settings
sysctl net.ipv4.tcp_congestion_control
sysctl net.core.rmem_max
sysctl net.core.wmem_max

# Optimize for high bandwidth * delay networks
sudo sysctl -w net.ipv4.tcp_congestion_control=bbr
sudo sysctl -w net.core.rmem_max=134217728
sudo sysctl -w net.core.wmem_max=134217728

# Make permanent in /etc/sysctl.d/99-network-tuning.conf
```

Remember: optimization without measurement is guesswork. Use iperf3 for bandwidth testing, sockperf for latency measurements.

## Practical Scenarios

Let me share some real world scenarios that illustrate these concepts in action.

### Scenario 1: Multi Homed Server

A web server needs connections to both DMZ and internal networks:

```bash
# Configure interfaces
nmcli con add con-name dmz type ethernet ifname eth0 \
  ipv4.method manual ipv4.addresses 10.1.1.10/24

nmcli con add con-name internal type ethernet ifname eth1 \
  ipv4.method manual ipv4.addresses 192.168.1.10/24

# Add specific routes
nmcli con mod internal +ipv4.routes "10.0.0.0/8 192.168.1.1"

# Prevent DMZ from becoming default route
nmcli con mod dmz ipv4.never-default yes
```

This ensures internal traffic stays internal while serving web content through the DMZ.

### Scenario 2: Network Migration

Migrating services between networks without downtime:

```bash
# Add new network address alongside old
sudo ip addr add 10.0.2.50/24 dev eth0 label eth0:migrate

# Test connectivity from new network
# Update DNS to include both IPs
# Monitor connections to old IP
ss -tn src 192.168.1.50

# Once traffic shifts, remove old address
sudo ip addr del 192.168.1.50/24 dev eth0
```

This approach allows gradual migration with rollback capability.

### Scenario 3: Debugging Container Networking

When containers can't communicate:

```bash
# Identify container namespace
docker inspect container_name | grep NetworkMode
docker inspect container_name | grep SandboxKey

# Enter network namespace
nsenter -t $(docker inspect -f '{{.State.Pid}}' container_name) -n

# Inside namespace, debug normally
ip addr show
ip route show
ping host.docker.internal
```

Understanding that containers use namespaces demystifies their networking.

## Looking Forward

Network configuration in Linux continues evolving. eBPF enables programmable networking, SR IOV brings hardware acceleration, and software defined networking changes how we think about network architecture.

But fundamentals remain: understanding how Linux models networks, mastering the tools, and thinking systematically about problems. Whether configuring a Raspberry Pi or orchestrating cloud infrastructure, these concepts scale.

The beauty of Linux networking lies in its transparency. Every connection, every packet, every decision is observable and configurable. Master these tools, understand these patterns, and you'll handle any network challenge with confidence.