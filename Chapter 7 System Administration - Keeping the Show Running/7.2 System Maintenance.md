# 7.2 System Maintenance

Picture this: You're responsible for a server that's been running flawlessly for 237 days. The business depends on it, users trust it, and management has forgotten it exists. Then one day, disk space hits 95%, logs have filled every available byte, and suddenly everyone remembers your name. Welcome to the reality of system maintenance, where the best work is invisible until it isn't.

After two decades of keeping systems healthy, I've learned that maintenance isn't about heroic rescues; it's about preventing the need for them. Modern Linux systems, especially when paired with AI assistance, can help you build maintenance routines that keep problems small and manageable. Let me show you how to think about system maintenance as a continuous practice rather than crisis management.

## The Maintenance Mindset

System maintenance is like dental hygiene for computers. Skip it, and small issues become painful emergencies. But unlike brushing your teeth, system maintenance involves multiple interconnected components that affect each other in subtle ways. Understanding these relationships transforms maintenance from a checklist of tasks into intelligent system stewardship.

Modern Linux systems generate tremendous amounts of operational data. Every service logs its activities, every process leaves traces, every user action creates artifacts. Without active maintenance, this accumulation eventually overwhelms even the most robust systems. The key is establishing routines that process this constant flow of information, keeping what's valuable and clearing what's not.

### The State of System Health

Before diving into specific maintenance tasks, let's understand what we're actually maintaining. A Linux system's health encompasses several dimensions:

**Storage Health**: Beyond simple disk space, this includes file system integrity, inode availability, and storage performance. I once troubleshot a system with 40% free space that couldn't create new files because it had exhausted its inodes. Modern file systems are remarkably resilient, but they still need attention.

**Performance Baseline**: Every system has a "normal" performance profile. CPU usage patterns, memory consumption, network throughput, disk I/O; these metrics tell a story about system health. Maintenance means understanding your baseline and investigating deviations.

**Security Posture**: Systems don't maintain their own security. Patches need applying, configurations drift, new vulnerabilities emerge. Security maintenance is an ongoing conversation between your systems and the evolving threat landscape.

**Service Reliability**: Applications and services degrade over time. Memory leaks accumulate, log files grow, temporary files multiply, database tables fragment. Regular maintenance keeps services running at peak efficiency.

## Core Maintenance Tasks

Let's explore the essential maintenance activities that keep Linux systems healthy. These aren't just commands to memorize; they're practices to understand and adapt to your environment.

### Log Management: The Art of Selective Memory

Logs are your system's memory, recording everything from routine operations to critical errors. But unlimited memory becomes a burden. Effective log management balances retention with resource consumption.

The modern approach to log management starts with understanding log rotation. Linux systems use logrotate to automatically archive and compress old logs:

```bash
# Understanding your current log rotation configuration
ls /etc/logrotate.d/
cat /etc/logrotate.conf

# Testing log rotation without waiting
logrotate -f /etc/logrotate.conf
```

But log rotation is just the beginning. The real skill is knowing what to keep and for how long. Production systems I've managed typically follow this pattern:

* Security logs: 90 days minimum, often longer for compliance
* Application logs: 30 days for debugging, 7 days for high volume services
* System logs: 30 days, with critical events forwarded to central logging

Here's a practical example of custom log rotation for a busy web application:

```bash
# /etc/logrotate.d/webapp
/var/log/webapp/*.log {
    daily
    rotate 7
    compress
    delaycompress
    missingok
    notifempty
    create 0640 webapp webapp
    sharedscripts
    postrotate
        systemctl reload webapp
    endscript
}
```

Beyond rotation, modern log management includes log analysis and alerting. The journald system on systemd-based distributions provides powerful filtering:

```bash
# View logs from the last boot only
journalctl -b

# Show errors from the last hour
journalctl --since "1 hour ago" -p err

# Follow specific service logs
journalctl -u nginx -f

# Export logs for analysis
journalctl --since yesterday --until today -o json > analysis.json
```

### Storage Maintenance: Beyond Disk Space

Storage maintenance encompasses more than watching disk usage percentages. Modern file systems require attention to fragmentation, integrity, and performance characteristics.

Start with understanding your storage layout:

```bash
# Comprehensive disk usage analysis
df -h
df -i  # Don't forget inode usage!

# Find space consumers
du -h --max-depth=1 / | sort -hr | head -20

# Locate large files
find / -type f -size +1G 2>/dev/null

# Identify old files
find /var/log -type f -mtime +30 -ls
```

But finding large files is just the start. Intelligent maintenance means understanding why space is being consumed:

```bash
# Analyze package cache
du -sh /var/cache/apt/archives  # Debian/Ubuntu
du -sh /var/cache/yum          # RHEL/CentOS

# Check for deleted but open files
lsof | grep deleted

# Review systemd journal size
journalctl --disk-usage
```

File system maintenance extends to integrity checking. While modern file systems like ext4 and XFS are incredibly robust, periodic checks catch issues before they become critical:

```bash
# Check file system (requires unmount)
fsck -n /dev/sda1  # Dry run

# Online file system check (XFS)
xfs_scrub /mount/point

# Verify file system integrity
e2fsck -f /dev/sda1  # ext4
```

### Package and Update Management

Keeping systems updated is a delicate balance. Updates fix security vulnerabilities and bugs but can introduce new issues. Successful maintenance requires a thoughtful approach to updates.

First, understand your current package state:

```bash
# List installed packages with versions
dpkg -l | less  # Debian/Ubuntu
rpm -qa | less  # RHEL/CentOS

# Check for available updates
apt list --upgradable    # Debian/Ubuntu
yum check-update        # RHEL/CentOS

# Review security updates specifically
apt list --upgradable | grep -i security
yum list-security
```

Develop an update strategy that matches your risk tolerance:

**Critical Security Updates**: Apply immediately, even on production systems
**Regular Security Updates**: Apply within a defined window (e.g., weekly)
**Feature Updates**: Test in non-production first, apply during maintenance windows
**Major Version Upgrades**: Extensive testing required, often warrant fresh installations

Here's a practical update workflow I've refined over years:

```bash
# Snapshot/backup before updates
# (Implementation depends on your infrastructure)

# Update package lists
apt update  # or yum makecache

# Review what will change
apt list --upgradable
apt show package-name  # Examine specific packages

# Perform updates
apt upgrade  # Conservative, no removals
apt full-upgrade  # More aggressive

# Verify system health post-update
systemctl status
journalctl -p err --since "10 minutes ago"
```

### System Performance Maintenance

Performance degradation creeps in slowly. Regular maintenance includes performance profiling and optimization:

```bash
# Memory maintenance
free -h
sync && echo 3 > /proc/sys/vm/drop_caches  # Clear caches

# Review memory consumers
ps aux --sort=-%mem | head

# Check for memory leaks
pmap -x PID  # Examine process memory

# Swap usage analysis
swapon -s
vmstat 1 10  # Monitor swap activity
```

Database maintenance deserves special attention, as databases often outlive the applications they serve:

```bash
# MySQL/MariaDB maintenance
mysqlcheck --all-databases --optimize

# PostgreSQL maintenance
vacuumdb --all --analyze

# MongoDB maintenance
db.repairDatabase()
db.collection.reIndex()
```

### Automation: Your Maintenance Multiplier

Manual maintenance doesn't scale. Automation transforms maintenance from a burden into a background process. Start with system cron jobs:

```bash
# Review existing maintenance jobs
ls /etc/cron.* 
crontab -l
systemctl list-timers

# Create custom maintenance scripts
cat > /usr/local/bin/daily-maintenance.sh << 'EOF'
#!/bin/bash
# Daily maintenance tasks

# Clean package cache
apt-get clean
yum clean all

# Remove old kernels (keep last 2)
package-cleanup --oldkernels --count=2

# Clean temporary files
find /tmp -type f -atime +7 -delete
find /var/tmp -type f -atime +7 -delete

# Rotate logs
logrotate -f /etc/logrotate.conf

# Update locate database
updatedb

# Check disk space
df -h | grep -E '^/dev/' | awk '$5 > 80 {print $0}'
EOF

chmod +x /usr/local/bin/daily-maintenance.sh
```

Modern maintenance leverages systemd timers for more flexible scheduling:

```bash
# Create a maintenance timer
cat > /etc/systemd/system/maintenance.timer << EOF
[Unit]
Description=Daily Maintenance Timer

[Timer]
OnCalendar=daily
Persistent=true

[Install]
WantedBy=timers.target
EOF

# Enable the timer
systemctl enable maintenance.timer
systemctl start maintenance.timer
```

## Advanced Maintenance Strategies

Beyond routine tasks, advanced maintenance involves predictive analysis and intelligent automation.

### Predictive Maintenance

Instead of reacting to problems, predict them:

```bash
# Disk space prediction
#!/bin/bash
# Predict when disk will fill based on growth rate

DAYS=30
PARTITION="/"

# Calculate daily growth
USAGE_NOW=$(df $PARTITION | awk 'NR==2 {print $3}')
USAGE_THEN=$(find /var/log -name "df-*.log" -mtime $DAYS | xargs cat | grep "^$PARTITION" | awk '{print $3}')
DAILY_GROWTH=$(( ($USAGE_NOW - $USAGE_THEN) / $DAYS ))

# Predict days until full
AVAILABLE=$(df $PARTITION | awk 'NR==2 {print $4}')
DAYS_UNTIL_FULL=$(( $AVAILABLE / $DAILY_GROWTH ))

echo "Partition $PARTITION growing at $DAILY_GROWTH KB/day"
echo "Estimated days until full: $DAYS_UNTIL_FULL"
```

### Maintenance Monitoring

Monitor your maintenance activities themselves:

```bash
# Track maintenance script execution
cat > /etc/rsyslog.d/maintenance.conf << EOF
:programname, isequal, "maintenance" /var/log/maintenance.log
& stop
EOF

# In maintenance scripts
logger -t maintenance "Starting daily maintenance"
logger -t maintenance "Cleaned $(du -sh /var/cache | cut -f1) from cache"
```

### Self-Healing Systems

Modern maintenance includes self-healing capabilities:

```bash
# Auto-restart failed services
cat > /usr/local/bin/service-watchdog.sh << 'EOF'
#!/bin/bash
SERVICES="nginx mysql redis"

for service in $SERVICES; do
    if ! systemctl is-active --quiet $service; then
        logger -t watchdog "Restarting failed service: $service"
        systemctl restart $service
        
        # Alert if restart fails
        if ! systemctl is-active --quiet $service; then
            logger -t watchdog -p err "Failed to restart $service"
            # Send alert (implementation depends on your monitoring)
        fi
    fi
done
EOF

# Run every 5 minutes via cron
*/5 * * * * /usr/local/bin/service-watchdog.sh
```

## Maintenance in Production

Production maintenance requires additional considerations. Here's wisdom earned from years of 3 AM pages:

**Change Windows**: Establish and respect maintenance windows. Even "safe" maintenance can have unexpected impacts.

**Rollback Plans**: Every maintenance action needs a reversal plan. Before cleaning that 50GB log file, ensure you don't need it.

**Communication**: Maintenance affects users. Communicate planned maintenance, even if you expect zero impact.

**Documentation**: Document your maintenance actions. Future you (or your successor) will thank present you.

**Monitoring**: Watch systems closely during and after maintenance. Some issues only appear under load.

## Modern Tools and Approaches

Contemporary maintenance leverages configuration management and monitoring tools:

**Configuration Management**: Tools like Ansible, Puppet, or Salt ensure consistent maintenance across fleets of servers.

**Monitoring Integration**: Prometheus, Grafana, and similar tools provide visibility into maintenance needs.

**Container Considerations**: Containerized environments shift some maintenance to the orchestration layer but don't eliminate it.

**Cloud Native Patterns**: Immutable infrastructure changes maintenance patterns but doesn't eliminate the need for system understanding.

## The Human Side of Maintenance

Maintenance is ultimately about people, the users who depend on these systems, the teams who manage them, the businesses they support. The best maintenance routines are invisible to users but visible to operators.

Build maintenance habits that scale with your environment. Start simple, automate gradually, and always understand what your automation is doing. The goal isn't to eliminate human judgment but to free it for more valuable tasks.

Remember, every expert started by breaking things and learning to fix them. Maintenance expertise comes from understanding systems deeply enough to keep them healthy, not just reacting when they're sick.

In the next section, we'll explore performance tuning, where maintenance meets optimization. For now, remember that consistent, thoughtful maintenance is the foundation of reliable systems. In the age of AI assistance, maintenance becomes less about memorizing commands and more about understanding what health looks like for your specific systems.